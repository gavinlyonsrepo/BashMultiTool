#!/bin/bash

#=========================HEADER==========================================

#name: bashmultitool
#Title: Bash Multi tool a bash library for commonly used functions 
#Description: Bash Multi tool a bash library file for commonly used functions
# to help rapidly build functioning an colorful scripts and Terminal user interfaces.
# see readme at repository for more details
#Version: 1.0
#License: MIT expat
#Written: Gavin Lyons

#====================FUNCTIONS===============================

#FUNCTION HEADER
# NAME: 
# DESCRIPTION:   
# INPUTS: 
# OUTPUTS:
# PROCESS:
# NOTES:
function BashMTFunc
{
	
local	hl=$(printf "\033[42;1m")
local	normal=$(printf "\033[0m")

local	black=$(printf "\033[0;30m")
local	red=$(printf "\033[0;31m")
local	green=$(printf "\033[0;32m")
local	tan=$(printf "\033[0;33m")
local	blue=$(printf "\033[0;34m")
local	purple=$(printf "\033[0;35m")
local	cyan=$(printf "\033[0;36m")
local	grey=$(printf "\033[0;37m")

local	b_grey=$(printf "\033[1;30m")
local	b_red=$(printf "\033[1;31m")
local	b_green=$(printf "\033[1;32m")
local	yellow=$(printf "\033[1;33m")
local	b_blue=$(printf "\033[1;34m")
local	b_purple=$(printf "\033[1;35m")
local	b_cyan=$(printf "\033[1;36m")
local	white=$(printf "\033[1;37m")


local	pacVar=""

case "$1" in 

	line) #print  horizontal line of =
		
		printf  "${b_cyan}%*s\n" "${COLUMNS:-$(tput cols)}" '' | tr ' ' "$2"
		printf '%s' "${normal}"
	;;
	
	anykey) #any key prompt, appends second text input to prompt
		printf '%s' "${green}" 
		read -n 1 -r -s -p "Press any key to continue $2"
		printf '%s\n' "${normal}"
	;;
	
	#print passed text string
	norm) printf '%s\n' "${normal}$2" ;;
	highlight)printf '%s\n' "${hl}$2${normal}" ;;
	
	black) printf '%s\n' "${black}$2${normal}" ;;
	red) printf '%s\n' "${red}$2${normal}" ;;
	green) printf '%s\n' "${green}$2${normal}" ;;
	tan)printf '%s\n' "${tan}$2${normal}" ;;
	blue) printf '%s\n' "${blue}$2${normal}" ;;
	purple)printf '%s\n' "${purple}$2${normal}" ;;
	cyan) printf '%s\n' "${cyan}$2${normal}" ;;
	grey) printf '%s\n' "${grey}$2${normal}" ;;

	b_grey) printf '%s\n' "${b_grey}$2${normal}" ;;
	b_red) printf '%s\n' "${b_red}$2${normal}" ;;
	b_green) printf '%s\n' "${b_green}$2${normal}" ;;
	yellow)printf '%s\n' "${yellow}$2${normal}" ;;
	b_blue) printf '%s\n' "${b_blue}$2${normal}" ;;
	b_purple)printf '%s\n' "${b_purple}$2${normal}" ;;
	b_cyan) printf '%s\n' "${b_cyan}$2${normal}" ;;
	white) printf '%s\n' "${white}$2${normal}" ;;
	
	yesno) #print yes no quit prompt
		local yesnoVar=""
		while true; do
			read -r yesnoVar
			case $yesnoVar in
				[Yy]*) return 0;;
				[Nn]*) return 1;;
				[Qq]*) return 255;;
				*) printf '%s\n' "${yellow}Please answer: (y/Y for yes) OR (n/N for no) OR (q/Q to quit)!${normal}";;
			esac
		done
	;;
	
	makedir)
		cd "$2" || errorhandlerBMTFunc "Cannot change to destination $2"
		local dirVar=""
		dirVar=$(date +%H%M-%d%b%y)"$3" 
		mkdir -p "$dirVar"
		cd "$dirVar" || errorhandlerBMTFunc "Cannot change to destination $dirVar"
		printf '%s\n' "Directory for output made at:-"
		pwd	 
		return 0
	;;
	
	spin)
		local spinner=( Ooooo oOooo ooOoo oooOo ooooO oooOo ooOoo oOooo);
		while true; do
			for i in "${spinner[@]}"; 
			do 
				# no new line , \r reset line       
				echo -ne "\r$i";
				sleep 0.2;
			done;
		done
	;;
	
	checkpac)
		case "$3" in
			1)  # pacman based
				pacVar=$(pacman -Qqs "$2")
			;;
			
			2)  # debian based
				pacVar=$(dpkg -l "$2" 2> /dev/null)
			;;
				
			3) # rpm based
				pacVar=$(rpm -qa | grep "$2" 2>/dev/null)
			;;
			
			*) # unknown
				printf '%s\n' "Error: Unsupported Linux distro"
				return 255
			;;
		esac
		
		if [ -n "$pacVar" ]
		then #installed
			#if text input is MES print good install message
			if [ "$4" = "MES" ] 
			then 
				printf '%s\n' "$2 is Installed"
			fi
			return 0
		else #not installed
			#if text input is MES print install bad message
			if [ "$4" = "MES" ] 
			then
				printf '%s\n' "${red}$2 is Not installed ${normal}"
			fi
			return 1
		fi 
	;;
	
	checknet)
			#This uses netcat (nc) in its port scan mode, 
			#a quick poke (-z is zero-I/O mode [used for 
			#scanning]) with a quick timeout 
			#(-w 1 waits at most one second
			#It checks passed website $1 on port 80 (HTTP).
		if nc -zw1 "$2" 80; then
			printf '%s\n' "We have connectivity $2"
			return 0
		else
			printf '%s\n' "${red}We do not have connectivity $2 ${normal}"
			return 1
		fi
	;;
	
	distrocheck)
			if [ -f /etc/redhat-release ]; then
				# rpm based
				return 1
			elif [ -f /etc/fedora-release ]; then
				# fedora based
				return 2
			elif [ -f /etc/lsb-release ]; then
				# deb based
				return 3
			elif [ -d /etc/pacman.d ]; then 
				# pacman based
				return 4
			elif [ -f /etc/gentoo-release ]; then 
				# gentoo based
				return 5
			elif [ -f /etc/slackware-release ]; then 
				# slackware based
				return 6
			else
				return 255
			fi
	;;
	*) # Catch all typos 
		errorhandlerBMTFunc "Unknown input to BashMTFunc"
	;;
esac
}

function errorhandlerBMTFunc 
{
	printf '%s\n' "$1"
	return 127
}
